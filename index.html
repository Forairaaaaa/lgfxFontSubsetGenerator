<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="jquery-3.5.1.min.js"></script>
</head>
<body>
    <div id="formMain">
        <div>
            フォントを選んでください：<br />
            <select id="selFont"></select>
        </div>
        <div>
            サブセットに含める文字を入力してください：<br />
            <textarea id="txtSubset" cols="80" rows="10"></textarea>
        </div>
        <div>
            <button id="btnGenerate" style="width:10em">生成</button>
        </div>
        <div id="divResult">
            処理結果：<br />
            <textarea id="txtResult" cols="80" rows="10"></textarea>
        </div>
    </div>

    <script language="javascript">

        const font_source = "LovyanGFX/src/Fonts/IPA/lgfx_font_japan.c";
        var font_master = new Map();
        var subset_generator = null;

        const dictFontName = new Map([
            ["lgfx_font_japan_gothic_8", { desc: "ゴシック体/等幅/8ピクセル", order: 1 }],
            ["lgfx_font_japan_gothic_12", { desc: "ゴシック体/等幅/12ピクセル", order: 2 }],
            ["lgfx_font_japan_gothic_16", { desc: "ゴシック体/等幅/16ピクセル", order: 3 }],
            ["lgfx_font_japan_gothic_20", { desc: "ゴシック体/等幅/20ピクセル", order: 4 }],
            ["lgfx_font_japan_gothic_24", { desc: "ゴシック体/等幅/24ピクセル", order: 5 }],
            ["lgfx_font_japan_gothic_28", { desc: "ゴシック体/等幅/28ピクセル", order: 6 }],
            ["lgfx_font_japan_gothic_32", { desc: "ゴシック体/等幅/32ピクセル", order: 7 }],
            ["lgfx_font_japan_gothic_36", { desc: "ゴシック体/等幅/36ピクセル", order: 8 }],
            ["lgfx_font_japan_gothic_40", { desc: "ゴシック体/等幅/40ピクセル", order: 9 }],
            ["lgfx_font_japan_gothic_p_8", { desc: "ゴシック体/プロポーショナル/8ピクセル", order: 10 }],
            ["lgfx_font_japan_gothic_p_12", { desc: "ゴシック体/プロポーショナル/12ピクセル", order: 11 }],
            ["lgfx_font_japan_gothic_p_16", { desc: "ゴシック体/プロポーショナル/16ピクセル", order: 12 }],
            ["lgfx_font_japan_gothic_p_20", { desc: "ゴシック体/プロポーショナル/20ピクセル", order: 13 }],
            ["lgfx_font_japan_gothic_p_24", { desc: "ゴシック体/プロポーショナル/24ピクセル", order: 14 }],
            ["lgfx_font_japan_gothic_p_28", { desc: "ゴシック体/プロポーショナル/28ピクセル", order: 15 }],
            ["lgfx_font_japan_gothic_p_32", { desc: "ゴシック体/プロポーショナル/32ピクセル", order: 16 }],
            ["lgfx_font_japan_gothic_p_36", { desc: "ゴシック体/プロポーショナル/36ピクセル", order: 17 }],
            ["lgfx_font_japan_gothic_p_40", { desc: "ゴシック体/プロポーショナル/40ピクセル", order: 18 }],
            ["lgfx_font_japan_mincho_8", { desc: "明朝体/等幅/8ピクセル", order: 19 }],
            ["lgfx_font_japan_mincho_12", { desc: "明朝体/等幅/12ピクセル", order: 20 }],
            ["lgfx_font_japan_mincho_16", { desc: "明朝体/等幅/16ピクセル", order: 21 }],
            ["lgfx_font_japan_mincho_20", { desc: "明朝体/等幅/20ピクセル", order: 22 }],
            ["lgfx_font_japan_mincho_24", { desc: "明朝体/等幅/24ピクセル", order: 23 }],
            ["lgfx_font_japan_mincho_28", { desc: "明朝体/等幅/28ピクセル", order: 24 }],
            ["lgfx_font_japan_mincho_32", { desc: "明朝体/等幅/32ピクセル", order: 25 }],
            ["lgfx_font_japan_mincho_36", { desc: "明朝体/等幅/36ピクセル", order: 26 }],
            ["lgfx_font_japan_mincho_40", { desc: "明朝体/等幅/40ピクセル", order: 27 }],
            ["lgfx_font_japan_mincho_p_8", { desc: "明朝体/プロポーショナル/8ピクセル", order: 28 }],
            ["lgfx_font_japan_mincho_p_12", { desc: "明朝体/プロポーショナル/12ピクセル", order: 29 }],
            ["lgfx_font_japan_mincho_p_16", { desc: "明朝体/プロポーショナル/16ピクセル", order: 30 }],
            ["lgfx_font_japan_mincho_p_20", { desc: "明朝体/プロポーショナル/20ピクセル", order: 31 }],
            ["lgfx_font_japan_mincho_p_24", { desc: "明朝体/プロポーショナル/24ピクセル", order: 32 }],
            ["lgfx_font_japan_mincho_p_28", { desc: "明朝体/プロポーショナル/28ピクセル", order: 33 }],
            ["lgfx_font_japan_mincho_p_32", { desc: "明朝体/プロポーショナル/32ピクセル", order: 34 }],
            ["lgfx_font_japan_mincho_p_36", { desc: "明朝体/プロポーショナル/36ピクセル", order: 35 }],
            ["lgfx_font_japan_mincho_p_40", { desc: "明朝体/プロポーショナル/40ピクセル", order: 36 }]
        ]);

        function toInt8(a) {
            if (a <= 127) {
                return a;
            } else {
                return a - 256;
            }
        }

        function concatUnique(list1, list2) {
            list2.forEach(item => {
                if (list1.indexOf(item) == -1) {
                    list1.push(item);
                }
            });
        }

        class FontFileHeader {
            constructor(...args) {
                if (args.length == 0) {
                    this.data = new Uint8Array(23);
                } else if (args.length == 1 && args[0] instanceof Uint8Array && args[0].length == 23) {
                    this.data = args[0];
                } else {
                    throw "FontFileHeader: Unexpected";
                }
            }

            get glyph_cnt() { return this.data[0]; }
            get bbx_mode() { return this.data[1]; }
            get bits_per_0() { return this.data[2]; }
            get bits_per_1() { return this.data[3]; }
            get bits_per_char_width() { return this.data[4]; }
            get bits_per_char_height() { return this.data[5]; }
            get bits_per_char_x() { return this.data[6]; }
            get bits_per_char_y() { return this.data[7]; }
            get bits_per_delta_x() { return this.data[8]; }
            get max_char_width() { return toInt8(this.data[9]); }
            get max_char_height() { return toInt8(this.data[10]); }
            get x_offset() { return toInt8(this.data[11]); }
            get y_offset() { return toInt8(this.data[12]); }
            get ascent_A() { return toInt8(this.data[13]); }
            get descent_g() { return toInt8(this.data[14]); }
            get ascent_para() { return toInt8(this.data[15]); }
            get descent_para() { return toInt8(this.data[16]); }
            get start_pos_upper_A() { return (this.data[17] << 8) | this.data[18]; }
            set start_pos_upper_A(p) { this.data[17] = p >> 8; this.data[18] = p & 0xff; }
            get start_pos_lower_a() { return (this.data[19] << 8) | this.data[20]; }
            set start_pos_lower_a(p) { this.data[19] = p >> 8; this.data[20] = p & 0xff; }
            get start_pos_unicode() { return (this.data[21] << 8) | this.data[22]; }
            set start_pos_unicode(p) { this.data[21] = p >> 8; this.data[22] = p & 0xff; }
        }

        class FontFile {
            constructor(org) {
                this.data = new Uint8Array(org);
                this.header = new FontFileHeader(this.data.subarray(0, 23));
            }

            getGlyph(char) {
                console.log("getGlyph(" + toHex(char) + ")");
                var ptr = 23;
                if (char <= 255) {
                    if (char >= 0x61) {
                        ptr += this.header.start_pos_lower_a;
                    } else if (char >= 0x41) {
                        ptr += this.header.start_pos_upper_A;
                    }
                    while (this.data[ptr + 1] != 0) {
                        if (this.data[ptr] == char) {
                            console.log("begin:" + toHex(ptr));
                            return new Glyph(this.data.subarray(ptr, ptr + this.data[ptr + 1]), false);
                        }
                        ptr += this.data[ptr + 1];
                    }
                } else {
                    ptr += this.header.start_pos_unicode;
                    var table = ptr;
                    var e;
                    do {
                        ptr += (this.data[table] << 8) | this.data[table + 1];
                        e = (this.data[table + 2] << 8) | this.data[table + 3];
                        if (e < 0xffff) {
                            var ptr2 = ptr;
                            var code;
                            while ((code = this.data[ptr2] << 8 | this.data[ptr2 + 1]) != 0) {
                                if (code == char) {
                                    console.log("begin:" + toHex(ptr2));
                                    return new Glyph(this.data.subarray(ptr2, ptr2 + this.data[ptr2 + 2]), true);
                                }
                                ptr2 += this.data[ptr2 + 2];
                            }
                        }
                        table += 4;
                    } while (e != 65535);
                }
                return null;
            }

            _getASCIICharArray(ptr) {
                var list = new Array();
                while (this.data[ptr + 1] != 0) {
                    list.push(this.data[ptr]);
                    ptr += this.data[ptr + 1];
                }
                return list;
            }

            _getUnicodeCharArray() {
                var ptr = 23 + this.header.start_pos_unicode;
                var table = ptr;
                var list = new Array();
                var e;
                do {
                    ptr += (this.data[table] << 8) | this.data[table + 1];
                    e = (this.data[table + 2] << 8) | this.data[table + 3];
                    var ptr2 = ptr;
                    var code;
                    while ((code = this.data[ptr2] << 8 | this.data[ptr2 + 1]) != 0) {
                        if (list.indexOf(code) == -1) {
                            list.push(code);
                        }
                        ptr2 += this.data[ptr2 + 2];
                    }
                    table += 4;
                } while (e != 0xffff);
                return list;
            }

            getCharArray() {
                var list = this._getASCIICharArray(23);
                concatUnique(list, this._getASCIICharArray(23 + this.header.start_pos_lower_a));
                concatUnique(list, this._getASCIICharArray(23 + this.header.start_pos_upper_A));
                concatUnique(list, this._getUnicodeCharArray());
                return list.sort((a, b) => a - b);
            }
        }

        class FontFileGenerator {
            constructor(template) {
                this.header = new FontFileHeader(Uint8Array.from(template.header.data));
                this.new_glyphs = new Array();
                this.data = null;
            }

            addGlyph(...args) {
                if (args.length == 1 && args[0] instanceof Array) {
                    this.new_glyphs = this.new_glyphs.concat(args[0]);

                } else if (args.length == 1 && args[0] instanceof Glyph) {
                    this.new_glyphs.push(args[0]);

                } else {
                    throw "addGlyph: Unimplemented";
                }
            }

            serialize() {
                var list = this.new_glyphs.sort((a, b) => a.code - b.code);
                var list_ascii = list.filter(a => a.code <= 0xff);
                var list_unicode = list.filter(a => a.code > 0xff);

                var end_of_ascii = [0x00];
                var unicode_lookup_table = [0x00, 0x04, 0xff, 0xff];
                var end_of_unicode = [0x00, 0x00];

                this.header.start_pos_upper_A = 0;
                this.header.start_pos_lower_a = 0;
                this.header.start_pos_unicode = FontFileGenerator.getGlyphArraySize(list_ascii) + end_of_ascii.length;

                var total_size = this.header.data.length;
                total_size += FontFileGenerator.getGlyphArraySize(list_ascii);
                total_size += end_of_ascii.length;
                total_size += unicode_lookup_table.length;
                total_size += FontFileGenerator.getGlyphArraySize(list_unicode);
                total_size += end_of_unicode.length;

                var newdata = new Uint8Array(total_size);

                newdata.set(this.header.data, 0);
                var ptr = this.header.data.length;

                ptr = FontFileGenerator._serializeGlyphArray(list_ascii, newdata, ptr);

                newdata.set(end_of_ascii, ptr);
                ptr += end_of_ascii.length;

                newdata.set(unicode_lookup_table, ptr);
                ptr += unicode_lookup_table.length;

                ptr = FontFileGenerator._serializeGlyphArray(list_unicode, newdata, ptr);

                newdata.set(end_of_unicode, ptr);

                this.data = newdata;
            }

            static _serializeGlyphArray(list, arr, ptr) {
                list.forEach(glyph => {
                    arr.set(glyph.data, ptr);
                    ptr += glyph.data.length;
                });
                return ptr;
            }

            static getGlyphArraySize(list) {
                var size = 0;
                list.forEach(glyph => {
                    size += glyph.data.length;
                });
                return size;
            }
        }

        class Glyph {
            constructor(raw_data, is_unicode) {
                this.data = raw_data;
                this.unicode = is_unicode;
                if (this.isUnicode) {
                    this.code = (this.data[0] << 8) | this.data[1];
                    this.raw_length = this.data[2];
                } else {
                    this.code = this.data[0];
                    this.raw_length = this.data[1];
                }
            }

            get isUnicode() { return this.unicode }
        }

        function toHex(v, digits = 0) {
            if (digits == 2 || (digits == 0 && v <= 0xff)) {
                return ('00' + v.toString(16).toUpperCase()).substr(-2);
            } else if (digits == 4 || (digits == 0 && v <= 0xffff)) {
                return ('0000' + v.toString(16).toUpperCase()).substr(-4);
            } else {
                return ('00000000' + v.toString(16).toUpperCase()).substr(-8);
            }
        }

        function generateCodeTable(list) {
            var table = $("<table border='1'>");
            var row = $("<tr></tr>");
            var row_code = 0;
            var cols = new Array(16);
            cols.fill(-1);
            list.forEach(code => {
                if (row_code != (code & 0xfff0)) {
                    if (cols.some((a) => a != -1)) {
                        $("<td>" + toHex(row_code) + "</td>").appendTo(row);
                        cols.forEach(c => {
                            var cell = $("<td width='30pt'></td>");
                            if (c != -1) {
                                cell.text(c);
                            } else {
                                cell.css("background-color", "gray");
                            }
                            cell.appendTo(row);
                        });
                        row.appendTo(table);
                        row = $("<tr></tr>");
                        cols.fill(-1);
                    }
                    row_code = code & 0xfff0;
                }
                cols[code & 0x000f] = String.fromCodePoint(code);
            });
            if (cols.some((a) => a != -1)) {
                $("<td>" + toHex(row_code) + "</td>").appendTo(row);
                cols.forEach(c => {
                    if (c == -1) {
                        c = "";
                    }
                    $("<td>" + c + "</td>").appendTo(row);
                });
                row.appendTo(table);
            }
            return table;
        }

        function unique(array) {
            return array.filter((elem, index, self) => self.indexOf(elem) === index);
        }

        function getSubsetCharList() {
            var subset_text = $("#txtSubset").val();
            var list = subset_text.split("").filter(a => a >= " ").map(a => a.codePointAt(0));
            return unique(list);
        }

        function clearLog() {
            $("#txtResult").val("");
        }

        function appendLog(msg, newline = true) {
            var ta = $("#txtResult");
            var txt = ta.val();
            if (txt == "") {
                txt = msg;
            } else if (newline) {
                txt = txt.concat("\n", msg);
            } else {
                txt = txt.concat(msg);
            }
            ta.val(txt);
            ta.scrollTop(ta[0].scrollHeight);
        }

        function outputHexDump(data) {
            var line = "";
            var i;
            for (i = 0; i < data.length; i++) {
                if ((i & 15) > 0) {
                    line += " ";
                }
                line += toHex(data[i], 2);
                if ((i & 15) == 15) {
                    console.log(line);
                    line = "";
                }
            }
            if (line != "") {
                console.log(line);
            }
        }

        function generateSubset(font, subset_list) {
            subset_generator = new FontFileGenerator(font);
            subset_list.forEach(code => {
                var glyph = font.getGlyph(code);
                subset_generator.addGlyph(glyph);
            });
            subset_generator.serialize();
            outputHexDump(subset_generator.data);
        }

        function decodeCString(str, buff, ptr) {
            var octbuff = "";
            var parsingOctal = false;
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                if (c == "\\") {
                    if (octbuff != "") {
                        buff[ptr] = Number.parseInt(octbuff, 8);
                        ptr++;
                    }
                    octbuff = "";
                    parsingOctal = true;
                } else {
                    if (parsingOctal) {
                        if (octbuff.length < 3 && "0" <= c && c <= "7") {
                            if (octbuff.length < 2 || (octbuff.length == 2 && octbuff[0] <= "3")) {
                                octbuff = octbuff.concat(c);
                            } else {
                                parsingOctal = false;
                            }
                        } else {
                            parsingOctal = false;
                        }
                    }
                    if (!parsingOctal) {
                        if (octbuff != "") {
                            buff[ptr] = Number.parseInt(octbuff, 8);
                            octbuff = "";
                            ptr++;
                        }
                        buff[ptr] = c.charCodeAt(0);
                        ptr++;
                    }
                }
            }
            if (octbuff != "") {
                buff[ptr] = Number.parseInt(octbuff, 8);
                ptr++;
            }
            return ptr;
        }

        function retrieveFonts(data) {
            var lines = data.split("\n");
            var reDeclaration = /^const\s+uint8_t\s+([A-Za-z0-9_]+)\s*\[\s*(\d+)\s*\]/;
            var reMiddlePart = /^"([^"]*)"$/;
            reMiddlePart.end_part = false;
            var reEndPart = /^"([^"]*)"\s*;$/;
            reEndPart.end_part = true;
            var font_name;
            var font_data = null;
            var size;
            var ptr;
            var error = false;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                var match = reDeclaration.exec(line);
                if (match != null) {
                    font_name = match[1];
                    size = Number.parseInt(match[2]);
                    font_data = new Uint8Array(size);
                    font_master.set(font_name, font_data);
                    ptr = 0;
                } else {
                    var isEndPart = false;
                    match = reMiddlePart.exec(line);
                    if (match == null) {
                        isEndPart = true;
                        match = reEndPart.exec(line);
                    }
                    if (match != null) {
                        ptr = decodeCString(match[1], font_data, ptr);
                        if (isEndPart) {
                            font_data[ptr] = 0;
                            ptr++;
                            if (size != ptr) {
                                appendLog("解析エラー " + font_name + " " + ptr + "/" + size);
                                error = true;
                            }
                            font_data = null;
                        }
                    }
                }
            }
            if (error) {
                throw "Error at retrieveFonts()";
            }
        }

        $(function () {
            $("#selFont").children().remove();
            clearLog();
            appendLog("フォントファイルを読み込んでいます... ");
            $.ajax({
                url: font_source,
                dataType: "text"
            }).then((data) => {
                return new Promise((resolve, reject) => {
                    appendLog("成功", false);
                    appendLog(data.length + "バイトのフォントファイルを読み込みました。");

                    appendLog("フォントファイルを解析しています... ");
                    setTimeout(() => resolve(data), 100);
                });

            }, () => {
                appendLog("失敗", false);
                throw "Error at ajax";

            }).then((data) => {
                retrieveFonts(data);
                appendLog("成功", false);
                appendLog(font_master.size + "個のフォントを読み込みました。");

                dictFontName.forEach((font_config, font_name) => {
                    if (font_master.has(font_name)) {
                        $("#selFont").append($('<option>').html(font_config.desc).val(font_name));
                    } else {
                        appendLog("\"" + font_name + "\"が見つかりません。");
                    }
                });

            }).catch(() => {
                appendLog("フォントファイルを読み込めませんでした。");

            });

        });

        

        $("#btnGenerate").on("click", function () {
            var font_name;
            var font;
            var orglist;
            (new Promise((resolve, reject) => {
                clearLog();
                subset_generator = null;
                font_name = $("#selFont").val();
                appendLog("元フォント\"" + font_name + "\"からサブセットを作成します。");
                appendLog("元フォントを解析します... ");
                setTimeout(() => resolve(), 100);

            })).then(() => {
                return new Promise((resolve, reject) => {
                    font = new FontFile(font_master.get(font_name));
                    orglist = font.getCharArray();
                    appendLog("成功", false);
                    appendLog("元フォントから" + orglist.length + "文字を読み込みました。");
                    setTimeout(() => resolve(), 100);
                });

            }).then(() => {
                return new Promise((resolve, reject) => {
                    var subset_list = getSubsetCharList();
                    var subset_list_filtered = subset_list.filter(a => orglist.includes(a));
                    var subset_list_error = subset_list.filter(a => !orglist.includes(a));
                    if (subset_list_error.length > 0) {
                        appendLog("以下の文字は元フォントに存在しません。生成するサブセットから除外されます。");
                        subset_list_error.forEach(code => {
                            appendLog("U+" + toHex(code) + " \"" + String.fromCodePoint(code) + "\"");
                        });
                    }
                    if (subset_list_filtered.length > 0) {
                        appendLog(subset_list_filtered.length + "文字のサブセットを作成します... ");
                        generateSubset(font, subset_list_filtered);
                        setTimeout(() => resolve(), 100);
                    } else {
                        appendLog("サブセットに含める文字がありません。");
                        reject();
                    }
                });

            }).then(() => {
                appendLog("成功", false);
                appendLog("作成したサブセットのデータサイズは" + subset_generator.data.length + "バイトです。");

            }, () => {
                console.log("aborted");
            });
        });

    </script>

</body>
</html>
