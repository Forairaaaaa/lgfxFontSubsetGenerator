<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="jquery-3.5.1.min.js"></script>
    <style type="text/css">
        body {
            padding: 0;
            margin: 0;
        }

        #formMain {
            margin: 0.5em;
        }

        #divModal {
            display: none;
            height: 100vh;
            position: fixed;
            top: 0;
            width: 100%;
        }

        #divModalBG {
            background: rgba(0,0,0,0.5);
            height: 100vh;
            position: absolute;
            width: 100%;
        }

        #divCharsetFrame {
            background: #fff;
            left: 50%;
            padding: 0.5em 1em 1em 1em;
            position: absolute;
            top: 50%;
            transform: translate(-50%,-50%);
            width: 40em;
            height: 30em;
        }

        #divCharsetHeader {
            vertical-align: middle;
            position: relative;
            padding-bottom: 0.2em;
        }

        #divFontName {
            float: left;
            font-weight: bold;
        }

        #divCloseCharset {
            width: 100%;
            text-align: right;
        }

        #divCharsetInnerFrame {
            position: relative;
            overflow-y: scroll;
            width: 100%;
            height: 28em;
        }

        table.CodeTable {
            border-collapse: collapse;
            border-spacing: 0px;
            border: 1px solid black;
        }

        table.CodeTable td {
            border: 1px solid black;
            vertical-align: middle;
        }

        td.char {
            width: 2em;
            height: 1em;
            text-align: center;
        }
    </style>
</head>
<body id="main">
    <div id="formMain">
        <div>
            フォントを選んでください：<br />
            <select id="selFont"></select><button id="btnShowCharset" style="width:10em">文字セットを見る</button>
        </div>
        <div>
            サブセットに含める文字を入力してください：<br />
            <textarea id="txtSubset" cols="80" rows="10"></textarea>
        </div>
        <div>
            <button id="btnGenerate" style="width:10em">生成</button>
            &nbsp;
            <button id="btnDownload" style="width:10em">ダウンロード</button>
        </div>
        <div id="divResult">
            処理結果：<br />
            <textarea id="txtResult" cols="80" rows="10"></textarea>
        </div>
    </div>

    <!-- 文字セット用モーダルウィンドウ -->
    <div id="divModal">
        <div id="divModalBG"></div>
        <div id="divCharsetFrame">
            <div id="divCharsetHeader">
                <div id="divFontName">(フォント名)</div><div id="divCloseCharset"><button id="btnCloseCharset">&nbsp;閉じる&nbsp;</button></div>
            </div>
            <div id="divCharsetInnerFrame"></div>
        </div>
    </div>

    <script language="javascript">

        // フォントファイルのURL
        const font_source = "LovyanGFX/src/Fonts/IPA/lgfx_font_japan.c";

        // 全フォント
        var font_master = new Map();

        // サブセット生成器(FontFileGenerator)
        var subset_generator = null;

        // フォントの一覧
        const dictFontName = new Map([
            ["lgfx_font_japan_gothic_8", { order: 1, name: "lgfxJapanGothic_8", desc: "ゴシック体/等幅/8ピクセル" }],
            ["lgfx_font_japan_gothic_12", { order: 2, name: "lgfxJapanGothic_12", desc: "ゴシック体/等幅/12ピクセル" }],
            ["lgfx_font_japan_gothic_16", { order: 3, name: "lgfxJapanGothic_16", desc: "ゴシック体/等幅/16ピクセル" }],
            ["lgfx_font_japan_gothic_20", { order: 4, name: "lgfxJapanGothic_20", desc: "ゴシック体/等幅/20ピクセル" }],
            ["lgfx_font_japan_gothic_24", { order: 5, name: "lgfxJapanGothic_24", desc: "ゴシック体/等幅/24ピクセル" }],
            ["lgfx_font_japan_gothic_28", { order: 6, name: "lgfxJapanGothic_28", desc: "ゴシック体/等幅/28ピクセル" }],
            ["lgfx_font_japan_gothic_32", { order: 7, name: "lgfxJapanGothic_32", desc: "ゴシック体/等幅/32ピクセル" }],
            ["lgfx_font_japan_gothic_36", { order: 8, name: "lgfxJapanGothic_36", desc: "ゴシック体/等幅/36ピクセル" }],
            ["lgfx_font_japan_gothic_40", { order: 9, name: "lgfxJapanGothic_40", desc: "ゴシック体/等幅/40ピクセル" }],
            ["lgfx_font_japan_gothic_p_8", { order: 10, name: "lgfxJapanGothicP_8", desc: "ゴシック体/プロポーショナル/8ピクセル" }],
            ["lgfx_font_japan_gothic_p_12", { order: 11, name: "lgfxJapanGothicP_12", desc: "ゴシック体/プロポーショナル/12ピクセル" }],
            ["lgfx_font_japan_gothic_p_16", { order: 12, name: "lgfxJapanGothicP_16", desc: "ゴシック体/プロポーショナル/16ピクセル" }],
            ["lgfx_font_japan_gothic_p_20", { order: 13, name: "lgfxJapanGothicP_20", desc: "ゴシック体/プロポーショナル/20ピクセル" }],
            ["lgfx_font_japan_gothic_p_24", { order: 14, name: "lgfxJapanGothicP_24", desc: "ゴシック体/プロポーショナル/24ピクセル" }],
            ["lgfx_font_japan_gothic_p_28", { order: 15, name: "lgfxJapanGothicP_28", desc: "ゴシック体/プロポーショナル/28ピクセル" }],
            ["lgfx_font_japan_gothic_p_32", { order: 16, name: "lgfxJapanGothicP_32", desc: "ゴシック体/プロポーショナル/32ピクセル" }],
            ["lgfx_font_japan_gothic_p_36", { order: 17, name: "lgfxJapanGothicP_36", desc: "ゴシック体/プロポーショナル/36ピクセル" }],
            ["lgfx_font_japan_gothic_p_40", { order: 18, name: "lgfxJapanGothicP_40", desc: "ゴシック体/プロポーショナル/40ピクセル" }],
            ["lgfx_font_japan_mincho_8", { order: 19, name: "lgfxJapanMincho_8", desc: "明朝体/等幅/8ピクセル" }],
            ["lgfx_font_japan_mincho_12", { order: 20, name: "lgfxJapanMincho_12", desc: "明朝体/等幅/12ピクセル" }],
            ["lgfx_font_japan_mincho_16", { order: 21, name: "lgfxJapanMincho_16", desc: "明朝体/等幅/16ピクセル" }],
            ["lgfx_font_japan_mincho_20", { order: 22, name: "lgfxJapanMincho_20", desc: "明朝体/等幅/20ピクセル" }],
            ["lgfx_font_japan_mincho_24", { order: 23, name: "lgfxJapanMincho_24", desc: "明朝体/等幅/24ピクセル" }],
            ["lgfx_font_japan_mincho_28", { order: 24, name: "lgfxJapanMincho_28", desc: "明朝体/等幅/28ピクセル" }],
            ["lgfx_font_japan_mincho_32", { order: 25, name: "lgfxJapanMincho_32", desc: "明朝体/等幅/32ピクセル" }],
            ["lgfx_font_japan_mincho_36", { order: 26, name: "lgfxJapanMincho_36", desc: "明朝体/等幅/36ピクセル" }],
            ["lgfx_font_japan_mincho_40", { order: 27, name: "lgfxJapanMincho_40", desc: "明朝体/等幅/40ピクセル" }],
            ["lgfx_font_japan_mincho_p_8", { order: 28, name: "lgfxJapanMinchoP_8", desc: "明朝体/プロポーショナル/8ピクセル" }],
            ["lgfx_font_japan_mincho_p_12", { order: 29, name: "lgfxJapanMinchoP_12", desc: "明朝体/プロポーショナル/12ピクセル" }],
            ["lgfx_font_japan_mincho_p_16", { order: 30, name: "lgfxJapanMinchoP_16", desc: "明朝体/プロポーショナル/16ピクセル" }],
            ["lgfx_font_japan_mincho_p_20", { order: 31, name: "lgfxJapanMinchoP_20", desc: "明朝体/プロポーショナル/20ピクセル" }],
            ["lgfx_font_japan_mincho_p_24", { order: 32, name: "lgfxJapanMinchoP_24", desc: "明朝体/プロポーショナル/24ピクセル" }],
            ["lgfx_font_japan_mincho_p_28", { order: 33, name: "lgfxJapanMinchoP_28", desc: "明朝体/プロポーショナル/28ピクセル" }],
            ["lgfx_font_japan_mincho_p_32", { order: 34, name: "lgfxJapanMinchoP_32", desc: "明朝体/プロポーショナル/32ピクセル" }],
            ["lgfx_font_japan_mincho_p_36", { order: 35, name: "lgfxJapanMinchoP_36", desc: "明朝体/プロポーショナル/36ピクセル" }],
            ["lgfx_font_japan_mincho_p_40", { order: 36, name: "lgfxJapanMinchoP_40", desc: "明朝体/プロポーショナル/40ピクセル" }]
        ]);

        // フォントヘッダ
        class FontFileHeader {
            constructor(...args) {
                if (args.length == 0) {
                    this.data = new Uint8Array(23);
                } else if (args.length == 1 && args[0] instanceof Uint8Array && args[0].length == 23) {
                    this.data = args[0];
                } else {
                    throw "FontFileHeader: Unexpected";
                }
            }

            get glyph_cnt() { return this.data[0]; }
            get bbx_mode() { return this.data[1]; }
            get bits_per_0() { return this.data[2]; }
            get bits_per_1() { return this.data[3]; }
            get bits_per_char_width() { return this.data[4]; }
            get bits_per_char_height() { return this.data[5]; }
            get bits_per_char_x() { return this.data[6]; }
            get bits_per_char_y() { return this.data[7]; }
            get bits_per_delta_x() { return this.data[8]; }
            get max_char_width() { return toInt8(this.data[9]); }
            get max_char_height() { return toInt8(this.data[10]); }
            get x_offset() { return toInt8(this.data[11]); }
            get y_offset() { return toInt8(this.data[12]); }
            get ascent_A() { return toInt8(this.data[13]); }
            get descent_g() { return toInt8(this.data[14]); }
            get ascent_para() { return toInt8(this.data[15]); }
            get descent_para() { return toInt8(this.data[16]); }
            get start_pos_upper_A() { return (this.data[17] << 8) | this.data[18]; }
            set start_pos_upper_A(p) { this.data[17] = p >> 8; this.data[18] = p & 0xff; }
            get start_pos_lower_a() { return (this.data[19] << 8) | this.data[20]; }
            set start_pos_lower_a(p) { this.data[19] = p >> 8; this.data[20] = p & 0xff; }
            get start_pos_unicode() { return (this.data[21] << 8) | this.data[22]; }
            set start_pos_unicode(p) { this.data[21] = p >> 8; this.data[22] = p & 0xff; }
        }

        // フォント
        class FontFile {
            constructor(org) {
                this.data = new Uint8Array(org);
                this.header = new FontFileHeader(this.data.subarray(0, 23));
            }

            // 文字コードを指定して文字を取得する。Glyphオブジェクトを返す。
            // ※返すデータは元データのsubarray
            getGlyph(char) {
                console.log("getGlyph(" + toHex(char) + ")");
                var ptr = 23;
                if (char <= 255) {
                    if (char >= 0x61) {
                        ptr += this.header.start_pos_lower_a;
                    } else if (char >= 0x41) {
                        ptr += this.header.start_pos_upper_A;
                    }
                    while (this.data[ptr + 1] != 0) {
                        if (this.data[ptr] == char) {
                            console.log("begin:" + toHex(ptr));
                            return new Glyph(this.data.subarray(ptr, ptr + this.data[ptr + 1]), false);
                        }
                        ptr += this.data[ptr + 1];
                    }
                } else {
                    ptr += this.header.start_pos_unicode;
                    var table = ptr;
                    var e;
                    do {
                        ptr += (this.data[table] << 8) | this.data[table + 1];
                        e = (this.data[table + 2] << 8) | this.data[table + 3];
                        if (e < 0xffff) {
                            var ptr2 = ptr;
                            var code;
                            while ((code = this.data[ptr2] << 8 | this.data[ptr2 + 1]) != 0) {
                                if (code == char) {
                                    console.log("begin:" + toHex(ptr2));
                                    return new Glyph(this.data.subarray(ptr2, ptr2 + this.data[ptr2 + 2]), true);
                                }
                                ptr2 += this.data[ptr2 + 2];
                            }
                        }
                        table += 4;
                    } while (e != 65535);
                }
                return null;
            }

            _getASCIICharArray(ptr) {
                var list = new Array();
                while (this.data[ptr + 1] != 0) {
                    list.push(this.data[ptr]);
                    ptr += this.data[ptr + 1];
                }
                return list;
            }

            _getUnicodeCharArray() {
                var ptr = 23 + this.header.start_pos_unicode;
                var table = ptr;
                var list = new Array();
                var e;
                do {
                    ptr += (this.data[table] << 8) | this.data[table + 1];
                    e = (this.data[table + 2] << 8) | this.data[table + 3];
                    var ptr2 = ptr;
                    var code;
                    while ((code = this.data[ptr2] << 8 | this.data[ptr2 + 1]) != 0) {
                        if (list.indexOf(code) == -1) {
                            list.push(code);
                        }
                        ptr2 += this.data[ptr2 + 2];
                    }
                    table += 4;
                } while (e != 0xffff);
                return list;
            }

            // 収録されている文字コードのリストを取得する
            getCharList() {
                var list = this._getASCIICharArray(23);
                concatUnique(list, this._getASCIICharArray(23 + this.header.start_pos_lower_a));
                concatUnique(list, this._getASCIICharArray(23 + this.header.start_pos_upper_A));
                concatUnique(list, this._getUnicodeCharArray());
                return list.sort((a, b) => a - b);
            }
        }

        // フォントファイル生成器
        class FontFileGenerator {
            constructor(template) {
                this.header = new FontFileHeader(Uint8Array.from(template.header.data));
                this.new_glyphs = new Array();
                this.data = null;
            }

            // 文字を追加する
            addGlyph(...args) {
                if (args.length == 1 && args[0] instanceof Array) {
                    this.new_glyphs = this.new_glyphs.concat(args[0]);

                } else if (args.length == 1 && args[0] instanceof Glyph) {
                    this.new_glyphs.push(args[0]);

                } else {
                    throw "addGlyph: Unimplemented";
                }
            }

            // シリアライズ
            serialize() {
                var list = this.new_glyphs.sort((a, b) => a.code - b.code);
                var list_ascii = list.filter(a => a.code <= 0xff);
                var list_unicode = list.filter(a => a.code > 0xff);

                var end_of_ascii = [0x00];
                var unicode_lookup_table = [0x00, 0x04, 0xff, 0xff];
                var end_of_unicode = [0x00, 0x00];

                this.header.start_pos_upper_A = 0;
                this.header.start_pos_lower_a = 0;
                this.header.start_pos_unicode = FontFileGenerator.getGlyphArraySize(list_ascii) + end_of_ascii.length;

                var total_size = this.header.data.length;
                total_size += FontFileGenerator.getGlyphArraySize(list_ascii);
                total_size += end_of_ascii.length;
                total_size += unicode_lookup_table.length;
                total_size += FontFileGenerator.getGlyphArraySize(list_unicode);
                total_size += end_of_unicode.length;

                var newdata = new Uint8Array(total_size);

                newdata.set(this.header.data, 0);
                var ptr = this.header.data.length;

                ptr = FontFileGenerator._serializeGlyphArray(list_ascii, newdata, ptr);

                newdata.set(end_of_ascii, ptr);
                ptr += end_of_ascii.length;

                newdata.set(unicode_lookup_table, ptr);
                ptr += unicode_lookup_table.length;

                ptr = FontFileGenerator._serializeGlyphArray(list_unicode, newdata, ptr);

                newdata.set(end_of_unicode, ptr);

                this.data = newdata;
            }

            static _serializeGlyphArray(list, arr, ptr) {
                list.forEach(glyph => {
                    arr.set(glyph.data, ptr);
                    ptr += glyph.data.length;
                });
                return ptr;
            }

            // Glyphオブジェクトの配列の全データサイズを取得する
            static getGlyphArraySize(list) {
                var size = 0;
                list.forEach(glyph => {
                    size += glyph.data.length;
                });
                return size;
            }
        }

        // 文字
        class Glyph {
            constructor(raw_data, is_unicode) {
                this.data = raw_data;
                this.unicode = is_unicode;
                if (this.isUnicode) {
                    this.code = (this.data[0] << 8) | this.data[1];
                    this.raw_length = this.data[2];
                } else {
                    this.code = this.data[0];
                    this.raw_length = this.data[1];
                }
            }

            get isUnicode() { return this.unicode }
        }

        // uint8からint8へ変換
        function toInt8(a) {
            if (a <= 127) {
                return a;
            } else {
                return a - 256;
            }
        }

        // 16進文字列へ変換
        function toHex(v, digits = 0) {
            if (digits == 2 || (digits == 0 && v <= 0xff)) {
                return ('00' + v.toString(16).toUpperCase()).substr(-2);
            } else if (digits == 4 || (digits == 0 && v <= 0xffff)) {
                return ('0000' + v.toString(16).toUpperCase()).substr(-4);
            } else {
                return ('00000000' + v.toString(16).toUpperCase()).substr(-8);
            }
        }

        // array1にarray2を連結。ただし既存の要素は含まない。
        function concatUnique(array1, array2) {
            array2.forEach(item => {
                if (array1.indexOf(item) == -1) {
                    array1.push(item);
                }
            });
        }

        // arrayから重複した要素を削除
        function unique(array) {
            return array.filter((elem, index, self) => self.indexOf(elem) === index);
        }

        // ログウィンドウをクリア
        function clearLog() {
            $("#txtResult").val("");
        }

        // ログウィンドウにメッセージを出力
        function appendLog(msg, newline = true) {
            var ta = $("#txtResult");
            var txt = ta.val();
            if (txt == "") {
                txt = msg;
            } else if (newline) {
                txt = txt.concat("\n", msg);
            } else {
                txt = txt.concat(msg);
            }
            ta.val(txt);
            ta.scrollTop(ta[0].scrollHeight);
        }

        // ログウィンドウに16進ダンプを出力
        function outputHexDump(data) {
            var line = "";
            var i;
            for (i = 0; i < data.length; i++) {
                if ((i & 15) > 0) {
                    line += " ";
                }
                line += toHex(data[i], 2);
                if ((i & 15) == 15) {
                    console.log(line);
                    line = "";
                }
            }
            if (line != "") {
                console.log(line);
            }
        }

        function generateCodeTableRow(row_code, cols) {
            if (cols.some((a) => a != -1)) {
                var row = $("<tr></tr>");
                row.append($("<td>" + toHex(row_code, 4) + "</td>"));
                cols.forEach(c => {
                    var cell = $("<td class='char'></td>");
                    if (c != -1) {
                        cell.text(c);
                    } else {
                        cell.css("background-color", "gray");
                    }
                    row.append(cell);
                });
                return row;
            } else {
                return null;
            }
        }

        // 文字セットの表を作成。table要素を返す。
        function generateCodeTable(list) {
            var table = $("<table class='CodeTable'>");
            var row = $("<tr></tr>");
            var row_code = 0;
            var cols = new Array(16);
            cols.fill(-1);
            list.forEach(code => {
                if (row_code != (code & 0xfff0)) {
                    var row = generateCodeTableRow(row_code, cols);
                    if (row != null) {
                        table.append(row);
                    }
                    cols.fill(-1);
                    row_code = code & 0xfff0;
                }
                cols[code & 0x000f] = String.fromCodePoint(code);
            });
            var row = generateCodeTableRow(row_code, cols);
            if (row != null) {
                table.append(row);
            }
            return table;
        }

        // サブセットに含めたい文字の文字コードを取得。重複を除く。arrayを返す。
        function getSubsetCharList() {
            var subset_text = $("#txtSubset").val();
            var list = subset_text.split("").filter(a => a >= " ").map(a => a.codePointAt(0));
            return unique(list);
        }

        // グローバル変数subset_generator上にサブセットを作成する
        function generateSubset(font, subset_list) {
            subset_generator = new FontFileGenerator(font);
            subset_list.forEach(code => {
                var glyph = font.getGlyph(code);
                subset_generator.addGlyph(glyph);
            });
            subset_generator.serialize();
            //outputHexDump(subset_generator.data);
        }

        // C言語の文字列プリミティブをデコードする
        function decodeCString(str, buff, ptr) {
            var octbuff = "";
            var parsingOctal = false;
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                if (c == "\\") {
                    if (octbuff != "") {
                        buff[ptr] = Number.parseInt(octbuff, 8);
                        ptr++;
                    }
                    octbuff = "";
                    parsingOctal = true;
                } else {
                    if (parsingOctal) {
                        if (octbuff.length < 3 && "0" <= c && c <= "7") {
                            if (octbuff.length < 2 || (octbuff.length == 2 && octbuff[0] <= "3")) {
                                octbuff = octbuff.concat(c);
                            } else {
                                parsingOctal = false;
                            }
                        } else {
                            parsingOctal = false;
                        }
                    }
                    if (!parsingOctal) {
                        if (octbuff != "") {
                            buff[ptr] = Number.parseInt(octbuff, 8);
                            octbuff = "";
                            ptr++;
                        }
                        buff[ptr] = c.charCodeAt(0);
                        ptr++;
                    }
                }
            }
            if (octbuff != "") {
                buff[ptr] = Number.parseInt(octbuff, 8);
                ptr++;
            }
            return ptr;
        }

        // グローバル変数font_master上にフォントを読み込む
        function retrieveFonts(data) {
            var lines = data.split("\n");
            var reDeclaration = /^const\s+uint8_t\s+([A-Za-z0-9_]+)\s*\[\s*(\d+)\s*\]/;
            var reMiddlePart = /^"([^"]*)"$/;
            reMiddlePart.end_part = false;
            var reEndPart = /^"([^"]*)"\s*;$/;
            reEndPart.end_part = true;
            var font_name;
            var font_data = null;
            var size;
            var ptr;
            var error = false;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                var match = reDeclaration.exec(line);
                if (match != null) {
                    font_name = match[1];
                    size = Number.parseInt(match[2]);
                    font_data = new Uint8Array(size);
                    font_master.set(font_name, font_data);
                    ptr = 0;
                } else {
                    var isEndPart = false;
                    match = reMiddlePart.exec(line);
                    if (match == null) {
                        isEndPart = true;
                        match = reEndPart.exec(line);
                    }
                    if (match != null) {
                        ptr = decodeCString(match[1], font_data, ptr);
                        if (isEndPart) {
                            font_data[ptr] = 0;
                            ptr++;
                            if (size != ptr) {
                                appendLog("解析エラー " + font_name + " " + ptr + "/" + size);
                                error = true;
                            }
                            font_data = null;
                        }
                    }
                }
            }
            if (error) {
                throw "Error at retrieveFonts()";
            }
        }

        // Uint8ArrayをＣ言語のコードに変換する
        function convertToCCode(data) {
            var lines = new Array();
            lines.push("#include <LovyanGFX.hpp>");
            lines.push("");
            lines.push("const uint8_t myFont_data[" + data.length + "] = {");
            var line = "";
            var i;
            for (i = 0; i < data.length; i++) {
                if ((i & 15) == 0) {
                    line += "    ";
                } else {
                    line += " ";
                }
                line += "0x" + toHex(data[i], 2);
                if (i < data.length - 1) {
                    line += ",";
                }
                if ((i & 15) == 15) {
                    lines.push(line);
                    line = "";
                }
            }
            if (line != "") {
                lines.push(line);
            }
            lines.push("};");
            lines.push("extern const lgfx::U8g2font myFont = { myFont_data };");
            lines.push("// このソースをスケッチに追加した後、フォントを利用するソースには、以下の定義を追加してください。");
            lines.push("// extern const lgfx::U8g2font myFont;");
            var text = lines.join("\n") + "\n";
            console.log(text);
            return text;
        }

        // READY
        $(function () {
            $("#selFont").children().remove();
            clearLog();
            appendLog("フォントファイルを読み込んでいます... ");
            $.ajax({
                url: font_source,
                dataType: "text"
            }).then(function (data) {
                return new Promise((resolve, reject) => {
                    appendLog("成功", false);
                    appendLog(data.length + "バイトのフォントファイルを読み込みました。");
                    appendLog("フォントファイルを解析しています... ");
                    setTimeout(() => resolve(data), 100);
                });

            }, function () {
                appendLog("失敗", false);
                throw "Error at ajax";

            }).then(function (data) {
                retrieveFonts(data);
                appendLog("成功", false);
                appendLog(font_master.size + "個のフォントを読み込みました。");

                dictFontName.forEach((font_config, font_name) => {
                    if (font_master.has(font_name)) {
                        $("#selFont").append($('<option>').html(font_config.desc).val(font_name));
                    } else {
                        appendLog("\"" + font_config.name + "\"が見つかりません。");
                    }
                });

            }).catch(() => {
                appendLog("フォントファイルを読み込めませんでした。");

            });
        });

        // 「文字セットを見る」
        $("#btnShowCharset").on("click", function () {
            var font_name;
            var charlist;
            (new Promise((resolve, reject) => {
                font_name = $("#selFont").val();
                appendLog("フォント\"" + dictFontName.get(font_name).name + "\"を解析します... ");
                setTimeout(() => resolve(), 100);

            })).then(function () {
                return new Promise((resolve, reject) => {
                    var font = new FontFile(font_master.get(font_name));
                    charlist = font.getCharList();
                    appendLog("成功", false);
                    appendLog(charlist.length + "文字を読み込みました。");
                    setTimeout(() => resolve(), 100);
                });

            }).then(function () {
                var content = generateCodeTable(charlist);
                $("#divFontName").text(dictFontName.get(font_name).name);
                $("#divCharsetInnerFrame").append(content);
                $("#divModal").fadeIn();
            });
        });

        // 「閉じる」（文字セット）
        $("#btnCloseCharset").on("click", function () {
            $("#divModal").fadeOut();
            $("#divCharsetInnerFrame").children().remove();
        });

        // ダウンロード用ファイル(Blob)
        var download_file = null;
        // ダウンロードURL(createObjectURLにより生成)
        var download_url = null;

        // ダウンロードURL(download_url)を開放
        function freeDownloadFileObject() {
            if (download_url != null) {
                URL.revokeObjectURL(download_url);
                download_url = null;
            }

        }

        // 「生成」
        $("#btnGenerate").on("click", function () {
            freeDownloadFileObject();
            var font_name;
            var font;
            var orglist;
            (new Promise((resolve, reject) => {
                clearLog();
                subset_generator = null;
                font_name = $("#selFont").val();
                appendLog("元フォント\"" + dictFontName.get(font_name).name + "\"からサブセットを作成します。");
                appendLog("元フォントを解析します... ");
                setTimeout(() => resolve(), 100);

            })).then(function () {
                return new Promise((resolve, reject) => {
                    font = new FontFile(font_master.get(font_name));
                    orglist = font.getCharList();
                    appendLog("成功", false);
                    appendLog("元フォントから" + orglist.length + "文字を読み込みました。");
                    setTimeout(() => resolve(), 100);
                });

            }).then(function () {
                return new Promise((resolve, reject) => {
                    var subset_list = getSubsetCharList();
                    var subset_list_filtered = subset_list.filter(a => orglist.includes(a));
                    var subset_list_error = subset_list.filter(a => !orglist.includes(a));
                    if (subset_list_error.length > 0) {
                        appendLog("以下の文字は元フォントに存在しません。生成するサブセットから除外されます。");
                        subset_list_error.forEach(code => {
                            appendLog("U+" + toHex(code) + " \"" + String.fromCodePoint(code) + "\"");
                        });
                    }
                    if (subset_list_filtered.length == 0) {
                        appendLog("サブセットに含める文字がありません。");
                        throw "aborted";
                    }
                    appendLog(subset_list_filtered.length + "文字のサブセットを作成します... ");
                    generateSubset(font, subset_list_filtered);
                    setTimeout(() => resolve(), 100);
                });

            }).then(function () {
                return new Promise((resolve, reject) => {
                    appendLog("成功", false);
                    appendLog("作成したサブセットのデータサイズは" + subset_generator.data.length + "バイトです。");
                    appendLog("C言語のソースコードに変換します... ");
                    setTimeout(() => resolve(), 100);
                });

            }).then(function () {
                var text = convertToCCode(subset_generator.data);
                download_file = new Blob([text], { type: "text/plain;charset=utf-8" });
                appendLog("成功", false);
                appendLog("作成したソースコードがダウロードできます。");

            }).catch(function (e) {
                console.log(e.toString());
            });
        });

        // 「ダウンロード」
        $("#btnDownload").on("click", function () {
            freeDownloadFileObject();
            var a = document.createElement("a");
            a.download = "myFont.cpp";
            download_url = URL.createObjectURL(download_file);
            console.log("URL: " + download_url);
            a.href = download_url;
            a.click();
        });

    </script>

</body>
</html>
